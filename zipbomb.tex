\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{usenix2019_v3}
\usepackage{amssymb}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{makecell}
\usepackage{pifont}
\usepackage{threeparttable}
\usepackage{xcolor}
\usepackage[binary-units,number-unit-product=~]{siunitx}

\urlstyle{same}
\def\sectionautorefname{Section}
\def\subsectionautorefname{Section}
% Better look for citations that include a section reference like \cite[\S 3]{foobar}.
\renewcommand{\citemid}{~}

% Disable metadata for reproducible PDF.
% https://tex.stackexchange.com/a/313605
\ifpdf
\pdfinfoomitdate=1
\pdftrailerid{}
\pdfsuppressptexinfo=-1
\hypersetup{pdfcreator={},pdfproducer={}}
\fi

\newcommand{\kB}{\kilo\byte}
\newcommand{\MB}{\mega\byte}
\newcommand{\GB}{\giga\byte}
\newcommand{\TB}{\tera\byte}
\newcommand{\PB}{\peta\byte}
\newcommand{\EB}{\exa\byte}
\newcommand{\EiB}{\exbi\byte}

\newcommand{\CDH}{\mbox{CDH}}
\newcommand{\LFH}{\mbox{LFH}}

\newcommand{\yes}{\cellcolor{YellowGreen}\checkmark}
\newcommand{\no}{\cellcolor{Bittersweet}\ding{55}}
\newcommand{\maybe}[1]{\cellcolor{GreenYellow}#1}

\begin{document}

\date{}

\title{\Large \bf A better zip bomb}

\author{
% ANON
% {\rm David Fifield}
}

\maketitle

\begin{abstract}
We show how to construct a
\emph{non-recursive} zip bomb
that achieves a high compression ratio by
overlapping files inside the zip container.
``Non-recursive'' means that it does not rely on
a decompressor's recursively unpacking zip files nested within zip files:
it expands fully after a single round of decompression.
The output size increases quadratically in the input size,
reaching a compression ratio of over 28~million
($\SI{10}{\MB} \rightarrow \SI{281}{\TB}$)
at the limits of the zip format.
Even greater expansion is possible using
64-bit extensions.
The construction uses only the most common compression algorithm, DEFLATE,
and is compatible with most zip implementations.
\end{abstract}


\section{Introduction}
\label{sec:intro}

Compression bombs that use the zip format
must cope with the fact that DEFLATE,
the only compression algorithm universally supported by zip parsers,
cannot achieve a compression ratio greater than
\num{1032}~\cite{zlib_tech}.
For this reason, zip bombs typically rely on recursive decompression,
nesting zip files within zip files to get an extra factor of 1032 with each layer.
But the trick only works on parsers that
unzip recursively, and most do not.
The best-known zip bomb, 42.zip~\cite{42.zip},
expands to a formidable \SI{4.5}{\PB}
if all six of its layers are recursively unzipped,
but a measly \SI{0.6}{\MB} at the top layer.
Zip quines, like those of
Ellingsen~\cite{ellingsen}
and Cox~\cite{cox},
which contain a copy of themselves
and thus expand infinitely if recursively unzipped,
are likewise perfectly safe to unzip once.

This article shows how to construct a non-recursive zip bomb
whose compression ratio surpasses the DEFLATE limit of 1032.
It works by overlapping files inside the zip container,
in order to include a ``kernel'' of highly compressed data
in multiple files, without making multiple copies of it.
The zip bomb's output size grows quadratically in the input size; i.e.,
the compression ratio gets better as the input file gets bigger.
The construction depends on specific features of both zip and DEFLATE---it
is not portable to other container formats or compression algorithms.
It is compatible with most zip parsers,
the exceptions being ``streaming'' parsers that
parse in one pass without first consulting the zip file's central directory.
The zip bomb construction tries to balance
two competing goals:
\begin{itemize}
\item
Maximize the compression ratio.
We define the compression ratio as the the sum of the sizes
of all the files contained the in the zip file,
divided by the size of the zip file itself.
It does not count filenames or other filesystem metadata,
only contents.
\item
Be compatible.
Zip is a tricky format and parsers differ, especially
around edge cases and optional features.
Avoid taking advantage of tricks that only work with certain parsers.
We will remark on ways to increase the efficiency of the zip bomb
that come with some loss of compatibility.
\end{itemize}


\section{Structure of a zip file}
\label{sec:zipstructure}

A~zip file consists of
a \emph{central directory} which references
\emph{files}.
Refer to \autoref{fig:normal}.

The central directory is at the end of the zip file.
It is a list of \emph{central directory headers}.
Each central directory header contains metadata for a single file,
like its filename and CRC-32 checksum,
and a backwards pointer to the file's local file header.
A~central directory header is 46~bytes long,
plus the length of the filename.

A~file consists of a \emph{local file header}
followed by compressed \emph{file data}.
The local file header is 30~bytes long,
plus the length of the filename.
It contains a redundant copy
of the metadata from the central directory header,
and the compressed and uncompressed sizes of the file data
which follows.
Zip is a container format, not a compression algorithm.
Each file's data is compressed by itself,
without reference to any other file,
using an external compression algorithm---usually DEFLATE~\cite{rfc1951}.

This description of the zip format omits many details that
are not needed to understand the construction of the zip bomb.
For full information,
refer to the file format specification~\cite{appnote},
particularly Section~4.3.

\begin{figure*}
\includegraphics{figures/normal}
\caption{
A normal zip file
(\autoref{sec:zipstructure}).
}
\label{fig:normal}
\end{figure*}


\section{The first insight: overlapping files}
\label{sec:overlap}

By compressing a long string of repeated bytes,
we can produce a \emph{kernel}
of highly compressed data.
By itself, the kernel's compression ratio cannot
exceed the DEFLATE limit of \num{1032},
so we want a way to reuse the kernel in many files,
without having to make a separate copy of it in each file.
We can do it by overlapping files:
making many central directory headers point to
a single file whose data is the kernel.
See \autoref{fig:overlap}.

\begin{figure*}
\includegraphics{figures/overlap}
\caption{
Full-overlap zip bomb construction
(\autoref{sec:overlap}).
This construction has problems with compatibility,
because filenames do not agree between the
central directory headers and the local file headers.
The ``kernel'' is a block of highly compressed data,
reused in every file.
}
\label{fig:overlap}
\end{figure*}

Let's look at an example to see how this construction affects the compression ratio.
Suppose the kernel is \SI{1000}{bytes} and
decompresses to \SI{1}{\MB}.
Then the first \SI{1}{\MB} of output ``costs''
\SI{1078}{bytes} of input:
\SI{31}{bytes} for a local file header (including a 1-byte filename),
\SI{47}{bytes} for a central directory header (including a 1-byte filename), and
\SI{1000}{bytes} for the kernel itself.
But every \SI{1}{\MB} of output
after the first costs only \SI{47}{bytes}---we don't need another local file header or copy of the kernel,
only an additional central directory header.
So while the first copy of the kernel has a compression ratio of
$\num{1000000}/\num{1078}\approx \num{928}$,
each additional copy pulls the ratio closer to
$\num{1000000}/\num{47}\approx \num{21277}$.
A~bigger kernel raises the ceiling.

The problem with this idea is a lack of compatibility.
The file metadata---specifically the filename---doesn't match
between the central directory header and local file header,
and some parsers balk at that.
See \autoref{tab:compatibility}.
Info-ZIP UnZip~\cite{infozip-unzip}
(the standard Unix \texttt{unzip} program)
extracts the files, but with warnings:

{\small
\begin{Verbatim}[commandchars=\\\{\}]
$ \textbf{unzip overlap.zip}
  inflating: A
B:  mismatching "local" filename (A),
         continuing with "central" filename version
  inflating: B
\textit{...}
\end{Verbatim}
}

\noindent
And the Python zipfile module~\cite{python-zipfile}
\href{https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L1486-L1489}{throws an exception}
when filenames don't match:

{\small
\begin{Verbatim}[commandchars=\\\{\}]
$ \textbf{python3 -m zipfile -e overlap.zip .}
Traceback (most recent call last):
\textit{...}
__main__.BadZipFile: File name in directory 'B' \textbackslash
and header b'A' differ.
\end{Verbatim}
}

Next we will see how to modify this construction
for filename consistency,
while still retaining most of the advantage
of overlapping files.

% If you are targeting a specific zip parser that you know
% does not check for filename consistency,
% this construction is a good one.
% It grows faster (as a function of the input size)
% than the construction of the next section,
% which has better compatibility
% because it uses separate local file headers.


\section{The second insight:\\quoting local file headers}
\label{sec:quote}

We need to somehow separate the local file headers for each file,
while still reusing a single kernel.
We'll use a feature of DEFLATE, non-compressed blocks,
to ``quote'' local file headers that occur later in the file
so that they appear to be part of the same DEFLATE stream
that terminates in the kernel.
Every local file header,
except the first,
will be interpreted two ways:
as code (part of the structure of the zip file format)
and as data (part of the output file data).

A~DEFLATE stream is a sequence of
blocks~\cite[\S 3.2.3]{rfc1951},
where each block can be compressed or non-compressed.
Compressed blocks are what we usually think of;
for example the kernel is one big compressed block.
But there are also non-compressed blocks,
which start with a
5-byte header~\cite[\S 3.2.4]{rfc1951}
that means simply, ``output the next $n$ bytes verbatim.''
Decompressing a non-compressed block means only stripping the 5-byte header.
Compressed and non-compressed blocks may be intermixed freely
in a DEFLATE stream.
The output is the concatenation of
decompressing all the blocks in order.

It is easiest to understand the construction from the inside out,
starting with the last file and working backwards to the first.
Refer to \autoref{fig:quote}.
Start by inserting the kernel, which will form the end of file data for every file.
Prepend a local file header $\LFH_N$
and add a central directory header $\CDH_N$ that points to it.
Set the ``compressed size'' metadata field in $\LFH_N$ and $\CDH_N$ to the compressed size of the kernel.
Now, insert before $\LFH_N$ a 5-byte non-compressed block header (colored green in the diagram)
whose length field is equal to the size of $\LFH_N$.
For the second time,
prepend a local file header $\LFH_{N-1}$
and add a central directory header $\CDH_{N-1}$ that points to it.
Set the ``compressed size'' metadata field in both headers to the compressed size of the kernel,
\emph{plus} the size of the non-compressed block header (\SI{5}{bytes}),
\emph{plus} the size of $\LFH_N$.

\begin{figure*}
\includegraphics{figures/quote}
\caption{
Quoted-overlap zip file construction
(\autoref{sec:quote}).
Each file contains the local file headers of all the files which follow it,
as well as the kernel.
The green parts stand for DEFLATE non-compressed blocks.
}
\label{fig:quote}
\end{figure*}

At this point the zip file contains two files.
Let's walk through what a zip parser would see while parsing it.
Supposed the compressed size of the kernel is \SI{1000}{bytes}
and the size of $\LFH_N$ is \SI{31}{bytes}.
We start at $\CDH_{N-1}$
and follow the pointer to $\LFH_{N-1}$.
The first file's filename is ``Y'' and
the compressed size of its file data is \SI{1036}{bytes}.
Interpreting the following \SI{1036}{bytes} as a DEFLATE stream,
we first encounter the 5-byte header of a non-compressed block
that says to copy the next \SI{31}{bytes}.
We write the next \SI{31}{bytes},
which happen to be $\LFH_N$,
as output to the file ``Y''.
Moving on in the DEFLATE stream, we find a compressed block (the kernel),
which we decompress to file ``Y''.
Now we have reached the end of the compressed data and are done with file ``Y''.
Proceeding to the next file, we follow the pointer from $\CDH_N$
to $\LFH_N$ and find a file with filename ``Z''
and compressed size \SI{1000}{bytes}.
Interpreting those \SI{1000}{bytes} as a DEFLATE stream,
we immediately encounter a compressed block (the kernel again)
and decompress it to the file ``Z''.
Now we have reached the end of the final file and are done.
The output file ``Z'' contains the decompressed kernel;
the output file ``Y'' is be the same, except additionally prefixed by
$\LFH_N$, \SI{31}{bytes} copied literally from the zip file.

The zip file is constructed by repeating the quoting procedure.
Each new file adds a central directory header,
a local file header,
and a non-compressed block to quote the next local file header.
Compressed file data is generally a chain of DEFLATE non-compressed blocks
(the quoted local file headers)
followed by the compressed kernel.
Each byte in the kernel contributes about
$\num{1032}N$ to the output size,
because it is part of all $N$ files.
The output files are not all the same size:
those that appear earlier in the zip file
are larger than those that appear later,
because they contain more local file headers.
The contents of the output files are nonsense,
but no one said they had to make sense.

This quoted-overlap construction has better compatibility
than the full-overlap construction of \autoref{sec:overlap},
but the compatibility comes at the expense of the compression ratio.
There, each added file cost only a central directory header;
but here, it costs a central directory header,
a local file header,
and another \SI{5}{bytes} for the quoting header.


\section{Optimization}
\label{sec:optimization}

Now that we have the basic zip bomb construction,
we will try to make it as efficient as possible.
We want to answer two questions:

\begin{itemize}
\item For a given zip file size, what's the maximum compression ratio?
\item What's the maximum compression ratio, given the limits of the zip format?
\end{itemize}

\subsection{Filenames}
\label{sec:filenames}

For our purposes, filenames are mostly dead weight.
While filenames do contribute something to the output size
by virtue of being part of quoted local file headers,
a byte in a filename does not contribute nearly as much to the output size
as does a byte in the kernel.
So we want filenames to be as short as possible,
while keeping them all distinct,
and subject to compatibility considerations.

The first compatibility consideration is filename encoding.
The zip format specification states that filenames
are to be interpreted as CP~437,
or \mbox{UTF-8} if a certain flag bit is set~\cite[Appendix~D]{appnote}.
But this is a major point of incompatibility
between zip parsers,
which may interpret filenames as being in
some fixed or locale-specific encoding, or ignore the \mbox{UTF-8} bit, for example.
So for compatibility, it's best to stick to characters
that have the same encoding in both
CP~437 and \mbox{UTF-8},
namely, the \num{95} printable characters of \mbox{US-ASCII}.
% https://bugs.python.org/issue10614
% https://bugs.python.org/issue10972

Another compatibility consideration is filesystem restrictions.
Some filesystems are case-insensitive, so ``a'' and ``A'' do not count as distinct names.
Common filesystems like FAT32 prohibit certain characters like
`*' and `?'~\cite[\S Limits]{wiki-fs}.

As a safe compromise between all these considerations,
our zip bomb will use filenames consisting of characters
drawn from a 36-character alphabet
that does not
rely on case distinctions
or use special characters:

\begin{center}
\setlength{\tabcolsep}{2pt}
\begin{tabular}{cccccccccccccccccc}
0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & A & B & C & D & E & F & G & H \\
I & J & K & L & M & N & O & P & Q & R & S & T & U & V & W & X & Y & Z
\end{tabular}
\end{center}
\noindent

Filenames are generated in the obvious way,
cycling each position through the possible characters
and adding a position on overflow:

\begin{center}
\setlength{\tabcolsep}{2pt}
\begin{tabular}{rrrrrrrrr}
``\mbox{0}'', &
``\mbox{1}'', &
``\mbox{2}'', &
\ldots, &
``\mbox{Z}'',
\\
``\mbox{00}'', &
``\mbox{01}'', &
``\mbox{02}'', &
\ldots, &
``\mbox{0Z}'', &
``\mbox{10}'', &
``\mbox{11}'', &
\ldots, &
``\mbox{ZZ}'',
\\
``\mbox{000}'', &
``\mbox{001}'', &
``\mbox{002}'', &
\ldots,
\end{tabular}
\end{center}
\noindent

Using this scheme, four character positions are enough for
\num{1727604} filenames.

% The length of the $n$\/th filename is
% $\lfloor \log_{36}((n + 1) / \frac{36}{35})\rfloor + 1$.
% The sum of the lengths of the first $n$ filenames is
% $dn - ((36^d - 1) \frac{36}{35^2} - \frac{d}{35})$,
% where $d = \lfloor \log_{36}(n / \frac{36}{35})\rfloor$.
% https://oeis.org/A014824

Given that the $N$ filenames in the zip file
are generally not all of the same length,
how should we order them,
shortest to longest or longest to shortest?
A little reflection shows that it is better to
put the longest names last, because those names are the most quoted.
Ordering filenames longest last
adds over \SI{900}{\MB} of output
in the ``large'' zip bomb we will see in \autoref{sec:allocation},
compared to ordering them longest first.
It is only a minor optimization, though,
as those \SI{900}{\MB} comprise only \num{0.0003}\%
of the total output size.

% $ unzip -l zblg.zip | tail -n 1
% 281395456244934                     65534 files
% $ unzip -l zblg.rev.zip | tail -n 1
% 281394526372494                     65534 files
% $ python
% >>> 281395456244934 - 281394526372494
% 929872440
% >>> 929872440 / 281395456244934. * 100
% 0.00033045041039703735

\subsection{Allocation}
\label{sec:allocation}

x

\section{Zip64}
\label{sec:zip64}

x

Somewhat related, Plötz et~al.~\cite[\S 4]{SAR-PR-2006-04}
used overlapping files to achieve
almost complete replication of the zip file itself.

\begin{table*}
\centering
\setlength{\tabcolsep}{4pt}
\begin{tabular}{rccccccc}
&
\thead{Info-ZIP\\UnZip~6.0~\cite{infozip-unzip}} &
\thead{Python~3.7\\zipfile~\cite{python-zipfile}} &
\thead{Go~1.12\\archive/zip~\cite{golang-archivezip}} &
\thead{yauzl~2.10.0~\cite{yauzl}\\(Node.js)} &
\thead{Nail~\cite{186219}\\examples/zip~\cite{nail-zip}} &
\thead{Android~9.0.0~r1\\libziparchive~\cite{android-libziparchive}} &
\thead{sunzip~0.4~\cite{sunzip}\\(streaming)}
\\
\thead[r]{DEFLATE} &
\yes &
\href{https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L57}{\yes} &
\href{https://github.com/golang/go/blob/go1.12/src/archive/zip/struct.go#L31}{\yes} &
\href{https://github.com/thejoshwolfe/yauzl/blob/2.10.0/index.js#L520-L521}{\yes} &
\href{https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.c#L63}{\yes} &
\href{https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive.cc#1059}{\yes} &
\href{https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L1256}{\yes}
\\
\thead[r]{Zip64} &
\href{http://infozip.sourceforge.net/UnZip.html#Release}{\yes} &
\href{https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L186}{\yes} &
\href{https://github.com/golang/go/blob/go1.12/src/archive/zip/reader.go#L519}{\yes} &
\href{https://github.com/thejoshwolfe/yauzl/tree/2.10.0#limitted-zip64-support}{\yes} &
\href{https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.c#L103-L125}{\no} &
\href{https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive.cc#168}{\no} &
\href{https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L922}{\yes}
\\
\thead[r]{bzip2} &
\href{http://infozip.sourceforge.net/UnZip.html#Release}{\yes} &
\href{https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L58}{\yes} &
\href{https://github.com/golang/go/blob/go1.12/src/archive/zip/struct.go#L28-L32}{\no} &
\href{https://github.com/thejoshwolfe/yauzl/blob/2.10.0/index.js#L517-L525}{\no} &
\href{https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.c#L86}{\no} &
\href{https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive.cc#1061}{\no} &
\href{https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L1256}{\yes}
\\
\thead[r]{tolerates mismatched filenames} &
\maybe{warns} &
\href{https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L1486-L1489}{\no} &
\href{https://github.com/golang/go/blob/go1.12/src/archive/zip/reader.go#L244}{\yes} &
\href{https://github.com/thejoshwolfe/yauzl/tree/2.10.0#local-file-headers-are-ignored}{\yes} &
\href{https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.nail#L49}{\yes} &
\href{https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive.cc#594}{\no} &
\href{https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L1268-L1269}{\yes}
\\
\thead[r]{tolerates incorrect CRC-32} &
\maybe{warns} &
\href{https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L893-L894}{\no} &
\href{https://github.com/golang/go/blob/go1.12/src/archive/zip/reader.go#L219-L224}{\maybe{if zero}} &
\href{https://github.com/thejoshwolfe/yauzl/tree/2.10.0#no-crc-32-checking}{\yes} &
\href{https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.nail#L41}{\no} &
\href{https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive.cc#52}{\yes} &
\href{https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L1465-L1469}{\no}
\\
\thead[r]{permits file size of $2^{32}-1$} &
\yes &
\href{https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L1311-L1313}{\yes} &
\href{https://github.com/golang/go/blob/go1.12/src/archive/zip/reader.go#L406-L414}{\yes} &
% ANON
\no & % \href{https://github.com/thejoshwolfe/yauzl/issues/109}{\no} &
\href{https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.nail#L59}{\yes} &
\href{https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive_common.h#95}{\yes} &
\href{https://github.com/madler/sunzip/blob/master/sunzip.c#L1275-L1277}{\yes}
\\
\thead[r]{permits file count of $2^{16}-1$} &
\yes &
\href{https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L258-L259}{\yes} &
\href{https://github.com/golang/go/blob/go1.12/src/archive/zip/reader.go#L502-L511}{\yes} &
% ANON
\no & % \href{https://github.com/thejoshwolfe/yauzl/issues/108}{\no} &
\href{https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.nail#L79}{\yes} &
\href{https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive_common.h#51}{\yes} &
\href{https://github.com/madler/sunzip/blob/master/sunzip.c#L1139}{\yes}
\\
\noalign{\vspace{0.5em}}
\thead[r]{parses full overlap\\(\autoref{sec:overlap})} &
\maybe{warns} &
\no &
\yes &
\yes &
\yes &
\no &
\no
\\
\thead[r]{parses quoted overlap\\(\autoref{sec:quote})} &
\yes &
\yes &
\yes &
\yes &
\yes &
\yes &
\no
\\
\thead[r]{parses quoted overlap Zip64\\(\autoref{sec:zip64})} &
\yes &
\yes &
\yes &
\yes &
\no &
\no &
\no
\end{tabular}
\caption{
Compatibility of selected zip parsers with various zip features,
edge cases,
and zip bomb constructions.
For best compatibility,
use DEFLATE compression without Zip64,
match names in central directory headers and local file headers,
compute correct CRCs,
and avoid the maximum values of 32-bit and 16-bit fields.
}
\label{tab:compatibility}
\end{table*}

\begin{table*}
\centering
\begin{threeparttable}
\begin{tabular}{rr|rr@{}l|rr@{}l}
&
&
\multicolumn{3}{c|}{\textbf{non-recursive}} &
\multicolumn{3}{c}{\textbf{recursive}}
\\
&
zipped size &
unzipped size &
\multicolumn{2}{r|}{ratio\phantom{~thousand}} &
unzipped size &
\multicolumn{2}{r}{ratio\phantom{~thousand}}
\\
Cox quine~\cite{cox} &
\num{440} &
\num{440} &
\num{1}&.0 &
$\infty$ &
$\infty$&
\\
Ellingsen quine~\cite{ellingsen} &
\num{28809} &
\num{42569} &
\num{1}&.5 &
$\infty$ &
$\infty$&
\\
42.zip~\cite{42.zip} &
\num{42374}\tnote{*} &
\num{558432} &
\num{13}&.2 &
\num{4507981343026016} &
106&~billion
\\
this technique &
\num{42374} &
\num{5461307620} &
129&~thousand &
\num{5461307620} &
129&~thousand
\\
this technique &
\num{9893525} &
\num{281395456244934} &
28&~million &
\num{281395456244934} &
28&~million
\\
this technique (Zip64) &
\num{45876952} &
\num{4507981427706459} &
98&~million &
\num{4507981427706459} &
98&~million
% \\
% this technique (Zip64) &
% \num{2961656712} &
% \num{18446744085437447493} &
% 6&~billion &
% \num{18446744085437447493} &
% 6&~billion
\end{tabular}
\caption{
Comparison of zip bomb constructions.
}
\label{tab:comparison}
\begin{tablenotes}
\item [*]
There are two versions of 42.zip,
an \href{https://web.archive.org/web/20120222083624/http://www.unforgettable.dk/}{older version} of \num{42374} bytes,
and a \href{https://web.archive.org/web/20120301154142/http://www.unforgettable.dk/}{newer version} of \num{42838} bytes.
The only difference between them is that the newer version has a password.
We use only the older version.
\end{tablenotes}
\end{threeparttable}
\end{table*}

% ANON
% \section*{Acknowledgements}

\section*{Availability}

% TODO: cryptobin

% ANON
% \url{https://www.bamsoftware.com/hacks/zipbomb/}

\bibliographystyle{plain}
\bibliography{zipbomb}

\end{document}
