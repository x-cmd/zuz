\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{usenix2019_v3}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{makecell}
\usepackage{pifont}
\usepackage{threeparttable}
\usepackage{xcolor}
\usepackage[binary-units,number-unit-product=~]{siunitx}

\urlstyle{same}
\def\sectionautorefname{Section}
\def\subsectionautorefname{Section}
% Better look for citations that include a section reference like \cite[\S 3]{foobar}.
\renewcommand{\citemid}{~}

% Disable metadata for reproducible PDF.
% https://tex.stackexchange.com/a/313605
\ifpdf
\pdfinfoomitdate=1
\pdftrailerid{}
\pdfsuppressptexinfo=-1
\hypersetup{pdfcreator={},pdfproducer={}}
\fi

\newcommand{\kB}{\kilo\byte}
\newcommand{\MB}{\mega\byte}
\newcommand{\GB}{\giga\byte}
\newcommand{\TB}{\tera\byte}
\newcommand{\PB}{\peta\byte}
\newcommand{\EB}{\exa\byte}
\newcommand{\EiB}{\exbi\byte}

\newcommand{\yes}{\cellcolor{YellowGreen}\checkmark}
\newcommand{\no}{\cellcolor{Bittersweet}\ding{55}}
\newcommand{\maybe}[1]{\cellcolor{GreenYellow}#1}

\begin{document}

\date{}

\title{\Large \bf A better zip bomb}

\author{
% ANON
% {\rm David Fifield}
}

\maketitle

\begin{abstract}
We show how to construct a
\emph{non-recursive} zip bomb
that achieves a high compression ratio by
overlapping files inside the zip container.
``Non-recursive'' means that it does not rely on
a decompressor's recursively unpacking zip files nested within zip files:
it expands fully after a single round of decompression.
The output size increases quadratically in the input size,
reaching a compression ratio of over 28~million
($\SI{10}{\MB} \rightarrow \SI{281}{\TB}$)
at the limits of the zip format.
Even greater expansion is possible using
64-bit extensions.
The construction uses only the most common compression algorithm, DEFLATE,
and is compatible with most zip implementations.
\end{abstract}


\section{Introduction}
\label{sec:intro}

Compression bombs that use the zip format
must cope with the fact that DEFLATE,
the only compression algorithm universally supported by zip parsers,
cannot achieve a compression ratio greater than
\num{1032}~\cite{zlib_tech}.
For this reason, zip bombs typically rely on recursive decompression,
nesting zip files within zip files to get an extra factor of 1032 with each layer.
But the trick only works on parsers that
unzip recursively, and most do not.
The best-known zip bomb, 42.zip~\cite{42.zip},
expands to a formidable \SI{4.5}{\PB}
if all six of its layers are recursively unzipped,
but a measly \SI{0.6}{\MB} at the top layer.
Zip quines, like those of
Ellingsen~\cite{ellingsen}
and Cox~\cite{cox},
which contain a copy of themselves
and thus expand infinitely if recursively unzipped,
are likewise perfectly safe to unzip once.

This article shows how to construct a non-recursive zip bomb
whose compression ratio surpasses the DEFLATE limit of 1032.
It works by overlapping files inside the zip container,
in order to include a ``kernel'' of highly compressed data
in multiple files, without making multiple copies of it.
The zip bomb's output size grows quadratically in the input size; i.e.,
the compression ratio gets better as the input file gets bigger.
The construction depends on specific features of both zip and DEFLATE---it
is not portable to other container formats or compression algorithms.
It is compatible with most zip parsers,
the exceptions being ``streaming'' parsers that
parse in one pass without first consulting the zip file's central directory.
The zip bomb construction tries to balance
two competing goals:
\begin{itemize}
\item
Maximize the compression ratio.
We define the compression ratio as the the sum of the sizes
of all the files contained the in the zip file,
divided by the size of the zip file itself.
It does not count filenames or other filesystem metadata,
only contents.
\item
Be compatible.
Zip is a tricky format and parsers differ, especially
around edge cases and optional features.
Avoid taking advantage of tricks that only work with certain parsers.
We will remark on ways to increase the efficiency of the zip bomb
that come with some loss of compatibility.
\end{itemize}


\section{Structure of a zip file}
\label{sec:zipstructure}

A~zip file consists of
a \emph{central directory} which references
\emph{files}.
Refer to \autoref{fig:normal}.

The central directory is at the end of the zip file.
It is a list of \emph{central directory headers}.
Each central directory header contains metadata for a single file,
like its filename and CRC-32 checksum,
and a backwards pointer to the file's local file header.
A~central directory header is 46~bytes long,
plus the length of the filename.

A~file consists of a \emph{local file header}
followed by compressed \emph{file data}.
The local file header is 30~bytes long,
plus the length of the filename.
It contains a redundant copy
of the metadata from the central directory header,
and the compressed and uncompressed sizes of the file data
which follows.
Zip is a container format, not a compression algorithm.
Each file's data is compressed by itself,
without reference to any other file,
using an external compression algorithm---usually DEFLATE~\cite{rfc1951}.

This description of the zip format omits many details that
are not needed to understand the construction of the zip bomb.
For full information,
refer to the file format specification~\cite{appnote},
particularly Section~4.3.

\begin{figure*}
\includegraphics{figures/normal}
\caption{
The structure of a normal zip file.
}
\label{fig:normal}
\end{figure*}


\section{The first insight: overlapping files}
\label{sec:overlap}

By compressing a long string of repeated bytes,
we can produce a \emph{kernel}
of highly compressed data.
By itself, the kernel's compression ratio cannot
exceed the DEFLATE limit of \num{1032},
so we want a way to reuse the kernel in many files,
without having to make a separate copy of it in each file.
We can do it by overlapping files:
making many central directory headers point to
a single file whose data is the kernel.
See \autoref{fig:overlap}.

Let's look at an example to see how this construction affects the compression ratio.
Suppose the kernel is \num{1000}~bytes and
decompresses to \SI{1}{\MB}.
Then the first \SI{1}{\MB} of output ``costs''
\num{1078} bytes of input:
\num{31} bytes for a local file header (including a 1-byte filename)</li>
<li>47 bytes for a central directory header (including a 1-byte filename)</li>
<li>1000 bytes for the kernel</li>
</ul>
<p>
But each additional <data value="1000000"><abbr title=megabyte>MB</abbr></data> of output
only costs 47 bytes—we don't need another copy of the local file header or the kernel,
only an additional central directory header.
The overall compression ratio is
$(\num{1000000} N) / (\num{47} N + 30 + 1000) \rightarrow {\sim}\num{21000}$,
and gets better as the kernel gets bigger.

<p>
The problem with this idea is that it's not very compatible.
The file metadata—the filename specifically—doesn't match
between the central directory header and local file header.
Some zip parsers only look at the metadata of one header or the other,
but other parsers look at both and compare.
<a href="http://infozip.sourceforge.net/UnZip.html">Info-ZIP UnZip</a>
(the standard Unix <code>unzip</code> program)
extracts the files, but with warnings:
</p>
<figure>
<pre>
$ <kbd>unzip overlap.zip</kbd>
<samp>  inflating: A
B:  mismatching "local" filename (A),
         continuing with "central" filename version
  inflating: B
<i>...</i></samp>
</pre>
</figure>
<p>
The Python <a href="https://docs.python.org/3/library/zipfile.html">zipfile</a> module
% <a href="https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L1486-L1489">throws an error</a>
when filenames don't match:
</p>
<figure>
<pre>
$ <kbd>python3 -m zipfile -e overlap.zip .</kbd>
<samp>Traceback (most recent call last):
<i>...</i>
% __main__.BadZipFile: File name in directory 'B' and header b'A' differ.</samp>
</pre>
</figure>
<!--
<p>
We could make every central directory header have the same filename
as the local file header, but that too is unsatisfying
because it means that if extracted to disk,
all the files will just overwrite each other and not take up more space
than a single file.
</p>
-->

<p>
If you are targeting a specific zip parser that you know
does not check for filename consistency,
this construction is a good one.
It grows faster (as a function of the input size)
than the construction of the next section,
which has better compatibility
because it uses separate local file headers.
</p>


Somewhat related, Plötz et~al.~\cite[\S 4]{SAR-PR-2006-04}
used overlapping files to achieve
almost complete replication of the zip file itself.

\begin{figure*}
\includegraphics{figures/overlap}
\caption{
xxx
The ``kernel'' is a block of DEFLATE-compressed data
that has a compression ratio
close to the maximum of \num{1032}.
}
\label{fig:overlap}
\end{figure*}


\section{Quoting file headers}
\label{sec:quote}

\begin{figure*}
\includegraphics{figures/quote}
\caption{
xxx
}
\label{fig:quote}
\end{figure*}


\section{Optimization}
\label{sec:optimization}

\subsection{Allocation}
\label{sec:allocation}


\section{Zip64}
\label{sec:zip64}


\begin{table*}
\centering
\setlength{\tabcolsep}{4pt}
\begin{tabular}{rccccccc}
&
\thead{Info-ZIP\\UnZip~6.0~\cite{infozip-unzip}} &
\thead{Python~3.7\\zipfile~\cite{python-zipfile}} &
\thead{Go~1.12\\archive/zip~\cite{golang-archivezip}} &
\thead{yauzl~2.10.0~\cite{yauzl}\\(Node.js)} &
\thead{Nail~\cite{186219}\\examples/zip~\cite{nail-zip}} &
\thead{Android~9.0.0~r1\\libziparchive~\cite{android-libziparchive}} &
\thead{sunzip~0.4~\cite{sunzip}\\(streaming)}
\\
\thead[r]{DEFLATE} &
\yes &
\href{https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L57}{\yes} &
\href{https://github.com/golang/go/blob/go1.12/src/archive/zip/struct.go#L31}{\yes} &
\href{https://github.com/thejoshwolfe/yauzl/blob/2.10.0/index.js#L520-L521}{\yes} &
\href{https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.c#L63}{\yes} &
\href{https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive.cc#1059}{\yes} &
\href{https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L1256}{\yes}
\\
\thead[r]{Zip64} &
\href{http://infozip.sourceforge.net/UnZip.html#Release}{\yes} &
\href{https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L186}{\yes} &
\href{https://github.com/golang/go/blob/go1.12/src/archive/zip/reader.go#L519}{\yes} &
\href{https://github.com/thejoshwolfe/yauzl/tree/2.10.0#limitted-zip64-support}{\yes} &
\href{https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.c#L103-L125}{\no} &
\href{https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive.cc#168}{\no} &
\href{https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L922}{\yes}
\\
\thead[r]{bzip2} &
\href{http://infozip.sourceforge.net/UnZip.html#Release}{\yes} &
\href{https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L58}{\yes} &
\href{https://github.com/golang/go/blob/go1.12/src/archive/zip/struct.go#L28-L32}{\no} &
\href{https://github.com/thejoshwolfe/yauzl/blob/2.10.0/index.js#L517-L525}{\no} &
\href{https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.c#L86}{\no} &
\href{https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive.cc#1061}{\no} &
\href{https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L1256}{\yes}
\\
\thead[r]{tolerates mismatched filenames} &
\maybe{warns} &
\href{https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L1486-L1489}{\no} &
\href{https://github.com/golang/go/blob/go1.12/src/archive/zip/reader.go#L244}{\yes} &
\href{https://github.com/thejoshwolfe/yauzl/tree/2.10.0#local-file-headers-are-ignored}{\yes} &
\href{https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.nail#L49}{\yes} &
\href{https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive.cc#594}{\no} &
\href{https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L1268-L1269}{\yes}
\\
\thead[r]{tolerates incorrect CRC-32} &
\maybe{warns} &
\href{https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L893-L894}{\no} &
\href{https://github.com/golang/go/blob/go1.12/src/archive/zip/reader.go#L219-L224}{\maybe{if zero}} &
\href{https://github.com/thejoshwolfe/yauzl/tree/2.10.0#no-crc-32-checking}{\yes} &
\href{https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.nail#L41}{\no} &
\href{https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive.cc#52}{\yes} &
\href{https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L1465-L1469}{\no}
\\
\thead[r]{permits file size of $2^{32}-1$} &
\yes &
\href{https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L1311-L1313}{\yes} &
\href{https://github.com/golang/go/blob/go1.12/src/archive/zip/reader.go#L406-L414}{\yes} &
\href{https://github.com/thejoshwolfe/yauzl/blob/2.10.0/index.js#L333-L348}{\no} &
\href{https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.nail#L59}{\yes} &
\href{https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive_common.h#95}{\yes} &
\href{https://github.com/madler/sunzip/blob/master/sunzip.c#L1275-L1277}{\yes}
\\
\thead[r]{permits file count of $2^{16}-1$} &
\yes &
\href{https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L893-L894}{\yes} &
\href{https://github.com/golang/go/blob/go1.12/src/archive/zip/reader.go#L502-L511}{\yes} &
\href{https://github.com/thejoshwolfe/yauzl/issues/108}{\no} &
\href{https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.nail#L79}{\yes} &
\href{https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive_common.h#51}{\yes} &
\href{https://github.com/madler/sunzip/blob/master/sunzip.c#L1139}{\yes}
\\
\noalign{\vspace{0.5em}}
\thead[r]{parses full overlap\\(\autoref{sec:overlap})} &
\maybe{warns} &
\no &
\yes &
\yes &
\yes &
\no &
\no
\\
\thead[r]{parses quoted overlap\\(\autoref{sec:quote})} &
\yes &
\yes &
\yes &
\yes &
\yes &
\yes &
\no
\\
\thead[r]{parses Zip64 quoted overlap\\(\autoref{sec:zip64})} &
\yes &
\yes &
\yes &
\yes &
\no &
\no &
\no
\end{tabular}
\caption{
Compatibility of selected zip parsers with various zip features,
edge cases,
and input files.
For best compatibility,
use DEFLATE compression without Zip64,
match names in central directory headers and local file headers,
compute correct CRCs,
and avoid the maximum values of 32-bit and 16-bit fields.
}
\label{tab:compatibility}
\end{table*}

\begin{table*}
\centering
\begin{threeparttable}
\begin{tabular}{rr|rr@{}l|rr@{}l}
&
&
\multicolumn{3}{c|}{\textbf{non-recursive}} &
\multicolumn{3}{c}{\textbf{recursive}}
\\
&
zipped size &
unzipped size &
\multicolumn{2}{r|}{ratio\phantom{~thousand}} &
unzipped size &
\multicolumn{2}{r}{ratio\phantom{~thousand}}
\\
Cox quine~\cite{cox} &
\num{440} &
\num{440} &
\num{1}&.0 &
$\infty$ &
$\infty$&
\\
Ellingsen quine~\cite{ellingsen} &
\num{28809} &
\num{42569} &
\num{1}&.5 &
$\infty$ &
$\infty$&
\\
42.zip~\cite{42.zip} &
\num{42374}\tnote{*} &
\num{558432} &
\num{13}&.2 &
\num{4507981343026016} &
106&~billion
\\
this technique &
\num{42374} &
\num{5461307620} &
129&~thousand &
\num{5461307620} &
129&~thousand
\\
this technique &
\num{9893525} &
\num{281395456244934} &
28&~million &
\num{281395456244934} &
28&~million
\\
this technique (Zip64) &
\num{45876952} &
\num{4507981427706459} &
98&~million &
\num{4507981427706459} &
98&~million
% \\
% this technique (Zip64) &
% \num{2961656712} &
% \num{18446744085437447493} &
% 6&~billion &
% \num{18446744085437447493} &
% 6&~billion
\end{tabular}
\caption{
Comparison of zip bomb constructions.
}
\label{tab:comparison}
\begin{tablenotes}
\item [*]
There are two versions of 42.zip,
an \href{https://web.archive.org/web/20120222083624/http://www.unforgettable.dk/}{older version} of \num{42374} bytes,
and a \href{https://web.archive.org/web/20120301154142/http://www.unforgettable.dk/}{newer version} of \num{42838} bytes.
The only difference between them is that the newer version has a password.
We compare only to the older version.
\end{tablenotes}
\end{threeparttable}
\end{table*}

% ANON
% \section*{Acknowledgements}

\section*{Availability}

% TODO: cryptobin

% ANON
% \url{https://www.bamsoftware.com/hacks/zipbomb/}

\bibliographystyle{plain}
\bibliography{zipbomb}

\end{document}
